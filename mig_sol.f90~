! information about the value functions
! get vmsep/vfsep=values of being single for males
! this is the value of remaining single, either because you started the period single and you reject the partner you meet or because you leave a relationship at
! the start of the period. not the value of starting period single, as it does not include the value of potentially entering into a relationship		  			
!get each spouse's consumption transfers for each j alternative using foc to the nb problem to get:
!share(2,cho): spouses' respective consumption shares of total income (pi) for each alternative cho
!these share solutions are conditional on the nb problem being well-defined. otherwise they don't mean anything
!i check for whether the nb problem is well-defined in the getnb subroutine later because i wait for marie
! checknb: check if the nb problem is well-defined meaning that there exists some allocation in the utility possibility set that is mutually beneficial
module sol
	use params
	use share
	use myaz
	implicit none
	real(sp) :: begintime,time(5)   
contains		
	subroutine solve
	real(dp) :: vec(5),vmax(2),val(2),vsum(2),vcheck(2)
	real(dp), dimension(nqs,nxs) :: vm0_s,vf0_s,vm_s,vf_s,prob_s
	real(dp), dimension(nq,nx) :: vm_c,vf_c,prob
	real(dp), dimension(nepsmove,nqs,nxs,nqs) :: vmr,vfr
	real(dp) :: vsingle(2,nqs,nxs,nz) ,surplus,transfers(2),test,vmarios(2),asum,vdif(2),testing(3)
	integer(i4b) :: ia,i,n,i0,z,g,j,imax,dd(11),jmax,iepsmove,qmax,relmax,pp,ppp,index,trueindex,ed(2)
	integer(i4b) :: q,x,q0,x0,qm,xm,qf,xf
    integer(i4b) :: iapp !ahu 030518 del and remove later
	logical :: welldef,haveenoughtomakeindiff,haveenoughtomakeindiff_alt,pc(2),pc_alt(2),intsol(3)
	!testing(1,1)=1 ; testing(1,2)=2 ; testing(1,3)=3 ; testing(2,1)=4 ; testing(2,2)=5 ; testing(2,3)=6
	!print*, "maxloc(testing,1),maxloc(testing,2)",maxloc(testing,1),maxloc(testing,2),"maxval",maxval(testing(2,:),1)   !,maxval(testing,2)
	!print*, nqs*nqs,nq*nq,count(pps(:,:,1)),count(ppc(:,:))
	begintime=secnds(0.0)
    !print*, 'Here is iter',iter
    
    if (groups) then 
        call cotyphome2index(myindex,myco,mytyp,myhome)
    else 
        myindex=0
    end if 
    !IF YOU WANT TO WRITE ALL THE BELOW, YOU HAVE TO COMMENT OUT THE OBJF PART WHERE IT SAYS IF ITER>1 SKRIV=.FALSE.
    if (skriv.and.iter==1) then 
        open(unit=99991, file='chkfnprof1.txt',status='replace')
    else if (skriv.and.iter==2) then
        open(unit=99991, file='chkfnprof2.txt',status='replace')
    else if (skriv.and.iter==3) then
        open(unit=99991, file='chkfnprof3.txt',status='replace')
    else if (skriv.and.iter==4) then
        open(unit=99991, file='chkfnprof4.txt',status='replace')
    else if (skriv.and.iter==5) then
        open(unit=99991, file='chkfnprof5.txt',status='replace')
    end if 
    if (skriv) then
        write(99991,'("Offer Employed:")') 
        write(99991,'("Males:")') 
        write(99991,'(15x,5x,"Get offer",5x,"Get ldoff",8x,"Nthing")') 
        write(99991,'("Not Educ",7x,3F14.6)') psio(1:2),zero  !fnprof(dw0,de,dsex) 
        write(99991,'("Not Educ",7x,3F14.6)') fnprof(1,1,1)  !fnprof(dw0,de,dsex) 
        write(99991,'("    Educ",7x,3F14.6)') psio(3:4),zero  !fnprof(dw0,de,dsex) 
        write(99991,'("    Educ",7x,3F14.6)') fnprof(1,2,1)  !fnprof(dw0,de,dsex) 
        write(99991,'("Females:")') 
        write(99991,'(15x,5x,"Get offer",5x,"Get ldoff",8x,"Nthing")') 
        write(99991,'("Not Educ",7x,3F14.6)') psio(5:6),zero  !fnprof(dw0,de,dsex) 
        write(99991,'("Not Educ",7x,3F14.6)') fnprof(1,1,2)  !fnprof(dw0,de,dsex) 
        write(99991,'("    Educ",7x,3F14.6)') psio(7:8),zero  !fnprof(dw0,de,dsex) 
        write(99991,'("    Educ",7x,3F14.6)') fnprof(1,2,2)  !fnprof(dw0,de,dsex) 
        write(99991,*) 
        write(99991,*) 
        write(99991,'("Offer Unemployed:")') 
        write(99991,'("Males:")') 
        write(99991,'(15x,5x,"Get offer",8x,"Nthing",8x,"Nthing")') 
        write(99991,'("Not Educ",7x,3F14.6)') psio(9),zero,zero  !fnprof(dw0,de,dsex) 
        write(99991,'("Not Educ",7x,3F14.6)') fnprof(np1,1,1)  !fnprof(dw0,de,dsex) 
        write(99991,'("    Educ",7x,3F14.6)') psio(10),zero,zero  !fnprof(dw0,de,dsex) 
        write(99991,'("    Educ",7x,3F14.6)') fnprof(np1,2,1)  !fnprof(dw0,de,dsex) 
        write(99991,'("Females:")') 
        write(99991,'(15x,5x,"Get offer",8x,"Nthing",8x,"Nthing")') 
        write(99991,'("Not Educ",7x,3F14.6)') psio(11),zero,zero  !fnprof(dw0,de,dsex) 
        write(99991,'("Not Educ",7x,3F14.6)') fnprof(np1,1,2)  !fnprof(dw0,de,dsex) 
        write(99991,'("    Educ",7x,3F14.6)') psio(12),zero,zero  !fnprof(dw0,de,dsex) 
        write(99991,'("    Educ",7x,3F14.6)') fnprof(np1,2,2)  !fnprof(dw0,de,dsex) 
        close(99991) 
    end if 
    
    call get_util_w
    if (onlysingles) then ; utilc=pen ; end if 
	insol=.true.
	!prob=0.0_dp
	decm0_s = ipen	; decf0_s = ipen  ; decm_s = ipen	; decf_s = ipen ; dec_mar=ipen ! dum is a dummy for yaz_checknb
    vm    = pen ; vf   = pen ; vm0_c = pen ; vf0_c = pen
    do trueindex=1,ninp
        if (groups) then 
            index=1
        else 
            index=trueindex
        end if
        ind: if ( (.not.groups) .or.  (myindex==trueindex) ) then !(myco==init(nn)%co.and.mytyp==typsim.and. myhome==init(nn)%hme)  ) then	  
		time(1)=secnds(0.0)
		emaxm_s=0.0_dp	; emaxf_s=0.0_dp ; emaxm_c=0.0_dp	; emaxf_c = 0.0_dp
		do ia=mxa,mna,-1
			print*, "mysay,ia,trueindex ",mysay,ia,trueindex !ahu 030622
			vmr  = pen ; vfr = pen	
			time(1)=secnds(0.0)
			if (ia==mxa) then 
				vm0_s = utils(1,:,:,trueindex) + ws(1,:,:,trueindex)		! v0: value function without movecost 
				vf0_s = utils(2,:,:,trueindex) + ws(2,:,:,trueindex)		! v0: value function without movecost
				vm0_c(:,:,ia,index) = utilc(1,:,:,trueindex)	! v0: value function without movecost, umar, consumption
				vf0_c(:,:,ia,index) = utilc(2,:,:,trueindex)	! v0: value function without movecost, umar, consumption
                
			else 
				vm0_s = utils(1,:,:,trueindex) + ws(1,:,:,trueindex)		+ delta * emaxm_s(:,:,ia+1)	! v0: value function without movecost 
				vf0_s = utils(2,:,:,trueindex) + ws(2,:,:,trueindex)		+ delta * emaxf_s(:,:,ia+1)	! v0: value function without movecost 
				vm0_c(:,:,ia,index) = utilc(1,:,:,trueindex)	+ delta * emaxm_c(:,:,ia+1)	! v0: value function without movecost, umar, consumption
				vf0_c(:,:,ia,index) = utilc(2,:,:,trueindex)	+ delta * emaxf_c(:,:,ia+1)	! v0: value function without movecost, umar, consumption
			end if 		
            
			whereami=1
			if (skriv.and.trueindex==1.and.(ia<=19.or.ia==45)) then ; yaz=.true. ; else ; yaz=.false. ; end if !ahu 0327 trueindex==2
			!if (skriv) yaz=.true.
            dd = -1 ; dd(1:2) = (/ia,trueindex/) 
			dd(7)=1 ; call getdec_s(dd,vm0_s,decm0_s(:,:,:,:,ia,index),vm(:,:,:,:,ia,index)) 
			yaz=.false.
			dd(7)=2 ; call getdec_s(dd,vf0_s,decf0_s(:,:,:,:,ia,index),vf(:,:,:,:,ia,index))	

			if (onlysingles) then 	
				decm_s(:,:,:,:,ia,index)=decm0_s(:,:,:,:,ia,index)
				decf_s(:,:,:,:,ia,index)=decf0_s(:,:,:,:,ia,index)
				vmr=vm(:,:,:,:,ia,index)
				vfr=vf(:,:,:,:,ia,index)
			else 
				whereamI=1 ! for telling yaz about where we are
				vec=pen
				do q0=1,nq	
                    if ( maxval(qq2w(:,q0)) <= np1 ) then !state variable part of the q space i.e. w <= np1

					vm_c=pen ; vf_c=pen
					prob=0.0_dp
					do x=1,nx	
						do q=1,nq
                            
                           !if (skriv.and.(ia==50).and.(q0<=15).and.(q>=190.and.q<=201).and.x==1.and.trueindex==1) then ; yaz=.true. ; else ; yaz=.false. ; end if  !ahumarch1122

                                !ahumarch1122 if ( skriv.and.q0==10.and. q2w( qq2q(1,q) )==np2 .and. q2w( qq2q(2,q) )==np2 .and. q2l( qq2q(1,q) )==1 .and. q2l( qq2q(2,q) )==1 ) then  !ahu030622 
                                    !ahumarch1122 print*, 'Is this it', q,q2w( qq2q(1,q) ),q2w( qq2q(2,q) ), q2l( qq2q(1,q) ) !ahu030622 
                                !ahumarch1122 end if  !ahu030622 
                            !ahumarch1122 
                            if (skriv.and.(ia==50.or.ia==48.or.ia==18).and.q0==4.and.q==92.and.x==19.and.trueindex==1) then ; yaz=.true. ; else ; yaz=.false. ; end if !ahu030822
                            !if (skriv.and.ia==48.and.q0==4.and.q==92.and.x==19.and.trueindex==1) then ; yaz=.true. ; else ; yaz=.false. ; end if !ahu030822
                            !if (skriv.and.ia==18.and.q0==4.and.q==92.and.x==19.and.trueindex==1) then ; yaz=.true. ; else ; yaz=.false. ; end if !ahu030822              
                            !if (skriv.and.(ia==48).and.(q0==4).and.q<=92.and.x==19.and.iepsmove==10.and.trueindex==1) then ; yaz=.true. ; else ; yaz=.false. ; end if  !ahu030622 !ahu030822
                            !if (skriv.and.(ia==48).and.(q0==4).and.(q>=190.and.q<=201).and.x==1.and.trueindex==1) then ; yaz=.true. ; else ; yaz=.false. ; end if  !ahu030622 !ahu030822
                                
                            !if (skriv.and.(ia<=18.or.ia==45.or.ia==49.or.ia==50).and.(q0<=15).and.(q>=190.and.q<=201).and.x==1.and.trueindex==1) then ; yaz=.true. ; else ; yaz=.false. ; end if  !ahu030622 !ahu030822
                            	!if (skriv.and.(ia==18.or.ia==49.or.ia==50).and.x==1.and.trueindex==1.and.q0<=50) then ; yazmax=.true. ; else ; yazmax=.false. ; end if
                           
                            !if (skriv.and.ia==48.and.q0==4.and.q==92.and.iepsmove==10.and.x==19.and.trueindex==1) then ; yaz=.true. ; else ; yaz=.false. ; end if !ahu030822
                        !ahu030822 Make sure you don't have iepsmove in the if statements here
                            if (skriv.and.ia==48.and.trueindex==1.and.x==19.and.q0==4.and.(q==92) ) then ; yazmax=.false. ; else ; yazmax=.false. ; end if

!ahu030622                  if (skriv.and.(ia==18.or.ia==50).and.(q>33.and.q<=37).and.(q0>=32.and.q0<=35).and.x==2) then ; yaz=.true. ; else ; yaz=.false. ; end if  
                            !if (skriv.and.(q0>=32.and.q0<=35).and.x==2.and.(q>=33.and.q<=37).and.(ia==mxa.or.ia==47)) then ; yaz=.false. ; else ; yaz=.false. ; end if  
                            !if (skriv.and.(ia>=40).and.(q0==18).and.q==24.and.x==1.and.trueindex==1) then ; yaz=.true. ; else ; yaz=.false. ; end if  !ahu 0327 trueindex==2
							if ( ppc(q,q0) ) then
								val=0.0_dp
								umar: do z=nz,1,-1		
                                    moveshocks: do iepsmove=1,nepsmove
                                        dd = (/ia,trueindex,q,x,z,q0,-1,-1,-1,-1,iepsmove /) 	! (/ ia,index,q,x,z,q0,gender,jmax,qmax,relmax,iepsmove /)  	
									    call getdec_c(dd,vmax)			    ! dd is inout and dd(8:10) tells you jmax,qmax,relmax
									    if (yaz) then ; call yaz_decision(dd,vmax) ; end if	! write down decision !ahu 032718 del and remove later. I uncommented this write										
									    val=val+ppso(iepsmove)*mgt(z)*vmax
                                    end do moveshocks
                                end do umar
								vm_c(q,x)=val(1) ; vf_c(q,x)=val(2)
							end if !pc0(q0)=.true. i.e. w(1) or w(2) are not np2 and pc
						end do !q
					end do !x
					!if (icheck_eqvmvf) then
					!	call check_eqvmvf(dd,vm_c,vf_c) 
					!end if 
					do x0=1,nx
                       ! if ( maxval(qq2w(:,q0)) <= np1 ) then !state variable part of the q space i.e. w <= np1
						    !prob=matmul( reshape(ppcq(:,q0,x0),(/nq,1/)) , reshape(ppcx(:,q0,x0),(/1,nx/)) )
						    !emaxm_c(q0,x0,ia)=sum(prob*vm_c)
						    !emaxf_c(q0,x0,ia)=sum(prob*vf_c)                    
                            emaxm_c(q0,x0,ia)=0.0_dp
						    emaxf_c(q0,x0,ia)=0.0_dp
                            do q=1,nq
                                do x=1,nx
						            emaxm_c(q0,x0,ia)=emaxm_c(q0,x0,ia)+ppcq(q,q0,x0)*ppcx(x,q0,x0)*vm_c(q,x)
						            emaxf_c(q0,x0,ia)=emaxf_c(q0,x0,ia)+ppcq(q,q0,x0)*ppcx(x,q0,x0)*vf_c(q,x)
                                end do 
                            end do 
                        !end if !state variable part of the q space i.e. w <= np1
					end do	 !x0						
                    end if 
                end do !q0
				
                !timeline: when single, you first decide on loc and work. and then when the day comes to an end, you go to the marriage market in whatever location you chose for that period.
				vm_s=0.0_dp ; vf_s=0.0_dp
				do xm=1,nxs					
                    ed(1)=x2e(xm)   !ahu summer18 051418: adding ed dimension to nonlabinc
					do qm=1,nqs	
						!no need for this ahu040518 vsingle=0.0_dp
						do xf=1,nxs			
                            ed(2)=x2e(xf)   !ahu summer18 051418: adding ed dimension to nonlabinc
							do qf=1,nqs
                                if (skriv.and.(ia==18).and.(qm==18).and.xm==1) then ; yaz=.true. ; else ; yaz=.false. ; end if     !ahu 0327 trueindex==2								
								    !no need for this ahu040518 sex: do g=1,2
									!no need for this ahu040518 if (g==1) then ; qm=qr ; qf=qp ; xm=xr ; xf=xp ; end if ! determine the match and the joint q from the combination
									!no need for this ahu040518 if (g==2) then ; qm=qp ; qf=qr ; xm=xp ; xf=xr ; end if ! determine the match and the joint q from the combination
									if (ppmeetq(qm,qf)>0.0_dp .and. ppmeetx(xm,xf)>0.0_dp) then 
										q = q2qq(qm,qf) 
										x = x2xx(xm,xf) 
										q0=-1	
										if (q2w(qm)>np1.or.q2w(qf)>np1.or.q==0.or.x==0) stop   !if (ps0(qm) .and. ps0(qf) .and. q > 0 .and. x >0) then ! all w should be <= np1	and q,x should exist
										vec(1) = vm0_s(qm,xm)
                                        vec(2) = vf0_s(qf,xf)
										marshock: do z=1,nz  
											dd = (/ ia,trueindex,q,x,z,q0,-1,-1,q,-1,-1 /) ! g and q0 is just -1 here (/ ia,index,q,x,z,q0,gender,j,q,rel,iepsmove /) 
                                                                                ! when in the marriage market, the index that corresponds to altq (i.e. i in yaz for example or dim 9 in dd) is just set to q since there is no altq in marriage market
                                            vec(3) = vm0_c(q,x,ia,index) + mg(z,trueindex) 
                                            vec(4) = vf0_c(q,x,ia,index) + mg(z,trueindex) 
                                            vec(5) = wc(1,q,x,trueindex) +  wc(2,q,x,trueindex) + nonlabinc(ed(1)) + nonlabinc(ed(2))                                                   
                                            !call checknb(dd,vec,welldef,vsum )  
                                            vdif(1)=vec(3)-vec(1)   !ahumarch1522 ahu031522 adding cornersol
                                            vdif(2)=vec(4)-vec(2)   !ahumarch1522 ahu031522 adding cornersol
                                            !ahumarch2122 ahu032122 replacing this with vdif for saving time surplus = vec(5) + vec(3) - vec(1) + vec(4) - vec(2)  
                                            surplus = vec(5) + sum(vdif(1:2))  !ahumarch2122 ahu032122 replacing with vdif for saving time
                                            pc(1:2)	= ( vdif + eps >= 0.0_dp )	!pc(1:2)    = ( vec(3:4) - vec(1:2) >= 0.0_dp )						        
                                            !ahu032122 ahumarch2122 commenting out to save time pc_alt(1:2)=( vdif >= 0.0_dp )	
                                            asum = sum(  one(.not. pc)  *   abs( vdif )   ) 
                                            haveenoughtomakeindiff=(  vec(5) + eps - asum  >= 0.0_dp  )
                                            !ahu032122 ahumarch2122 commenting out to save time haveenoughtomakeindiff_alt=(  vec(5) - asum  >= 0.0_dp  )
                                            !In orer for NB to be well defined, we need: 1) surplus>=0 2) there exists some transfer such that transfer1>=0 and transfer2>=0
                                            !Condition 2 follows from the requirement that the utility transfer has to only come from current wsum and not the V's. In other words, 
                                            !w has to be such that it can cover any utility transfers that are needed o have the PC's hold. 
                                            !See notes in black notebook about why Condition 2 translates into that asum condition. 
                                            !Once we establish that NB is well defined, then we can go ahead and see if the optimum is interior or corner. 
                                            !ahumarch2122 ahu032122 moving eps to the other side intsol(2)=( vec(5) + eps < vdif(1)-vdif(2)   )      !corner where c1=0 and c2=wsum
                                            !ahumarch2122 ahu032122 moving eps to the other side intsol(3)=( vec(5) + eps < vdif(2)-vdif(1)   )      !corner where c1=wsum and c2=0
                                            intsol(1)=( vec(5) + eps >= abs(vdif(1)-vdif(2)) )  !interior
                                            intsol(2)=( vec(5) <= vdif(1)-vdif(2) + eps  )      !corner where c1=0 and c2=wsum !ahumarch2122 ahu032122 moving eps to the other side
                                            intsol(3)=( vec(5) <= vdif(2)-vdif(1) + eps  )      !corner where c1=wsum and c2=0 !ahumarch2122 ahu032122 moving eps to the other side

                                            if (surplus+eps>0.0_dp .and. haveenoughtomakeindiff ) then
                                            !ahumarch1522 Now check if the interior condition is really indeed satisfied but get rid of this later
                                            if ( intsol(1) ) then       !ahumarch1522 interiorcheck adding cornersol                                            
                                                welldef=.TRUE.          !ahumarch1522
                                                !ahumarch2122 ahu032122 replacing with vdif to save time transfers(1) = alf * surplus - ( vec(3)-vec(1) )                                                
                                                !ahumarch2122 ahu032122 replacing with vdif to save time transfers(2) = (1.0_dp-alf) * (vec(5) + vec(3) - vec(1) ) - alf*( vec(4)-vec(2) )   
                                                transfers(1) = alf * surplus -  vdif(1)                     !ahumarch2122 ahu032122 replacing with vdif to save time                                           
                                                transfers(2) = (1.0_dp-alf) * (vec(5) + vdif(1) ) - alf*vdif(2) !ahumarch2122 ahu032122 replacing with vdif to save time   
                                                vmarios(1:2)=vec(3:4)+transfers(1:2)
                                               !ahumarch1522 Now check if the interior condition is really indeed satisfied but get rid of this later
                                              !  if (vec(5)-abs(vdif(1)-vdif(2)) < 0.0_dp ) then !ahumarch1522 if the transfers statement is correct, then this should be correct too!
                                              !      print*, "There is something wrong!", ia,q0,q,x,vec(5),abs(vdif(1)-vdif(2))  !ahumarch1522
                                              !      stop                                                    !ahumarch1522
                                              !  end if                                                      !ahumarch1522 
                                              !  if ( minval(transfers) + eps2 < 0.0_dp .or. maxval(transfers) > vec(5)+eps2 ) then ! if (minval(transfers)>0.0_dp.and.maxval(transfers)<vec(5) ) then 
                                              !      print*, "Int cond fine but transfers not fine!", ia,q0,q,x,z,transfers(1:2),vec(5)  !ahumarch1522
                                              !       stop                                                                    !ahumarch1522                            
                                              !   end if 
                                              !   if ( minval(transfers) < 0.0_dp .or. maxval(transfers) > vec(5) ) then ! if (minval(transfers)>0.0_dp.and.maxval(transfers)<vec(5) ) then 
                                              !       print*, "Int cond fine but transfers not fine 2!", ia,q0,q,x,z,transfers(1:2),vec(5)  !ahumarch1522
                                                 !   stop                                                                    !ahumarch1522                            
                                                !end if 
                                            else if ( intsol(2) ) then                      !ahumarch1522 adding cornersol
                                                welldef=.TRUE.                              !ahumarch1522 adding cornersol
                                                transfers(1)=0.0_dp                         !ahumarch1522 adding cornersol
                                                transfers(2)=vec(5)                         !ahumarch1522 adding cornersol
                                                vmarios(1:2)=vec(3:4)+transfers(1:2)
                                                !if (vec(5) >= vdif(1)-vdif(2) ) then        !ahumarch1522 adding cornersol
                                                !    print*, "There is somethingwrong in corner1!", ia,q0,q,x,z,vec(5),vdif(1)-vdif(2)  !ahumarch1522 adding cornersol
                                                !    stop
                                                !end if                                       !ahumarch1522 adding cornersol
                                            else if ( intsol(3) ) then                      !ahumarch1522 adding cornersol
                                                welldef=.TRUE.                              !ahumarch1522 adding cornersol
                                                transfers(1)=vec(5)                         !ahumarch1522 adding cornersol
                                                transfers(2)=0.0_dp                         !ahumarch1522 adding cornersol
                                                vmarios(1:2)=vec(3:4)+transfers(1:2)
                                                !if (vec(5) >= vdif(2)-vdif(1) ) then        !ahumarch1522 adding cornersol
                                                !    print*, "There is somethingwrong in corner2!", ia,q0,q,x,z,vec(5),vdif(1)-vdif(2)  !ahumarch1522 adding cornersol
                                                !    stop
                                                !end if                                       !ahumarch1522 adding cornersol
                                            else 
                                                print*, "Tried everything but I should not end up here"
                                                stop
                                            end if
                                    else    !NB not well defined either because surplus si negative off the bat or because don't have enough to make indiff
                                        welldef=.FALSE.
                                        transfers=pen
                                    end if 
                                    if (welldef) then
										dec_mar(z,q,x,ia,index)=1
                                        vsum(1:2)=vmarios(1:2)
                                        val=vsum(1:2)                                                
                                    else 
                                        dec_mar(z,q,x,ia,index)=0
                                        vsum=pen
										val=vec(1:2) 
                                    end if 


                                     !        surplus = vec(5) + vec(3) - vec(1) + vec(4) - vec(2)  
                                     !       transfers=pen
                                     !       if (surplus+eps>0.0_dp) then
                                     !           welldef=.TRUE.
                                     !           if (nonneg) then
		                             !               transfers(1) = alf * surplus - ( vec(3)-vec(1) )                                                
		                             !               transfers(2) = (1.0_dp-alf) * (vec(5) + vec(3) - vec(1) ) - alf*( vec(4)-vec(2) )           
		                             !               if ( minval(transfers) + eps2 >= 0.0_dp .and. maxval(transfers) <= vec(5)+eps2 ) then ! if (minval(transfers)>0.0_dp.and.maxval(transfers)<vec(5) ) then 
                                     !                   welldef=.TRUE.
                                     !               else
                                     !                   welldef=.FALSE.
                                     !               end if
                                     !           end if
                                     !       else 
									!			welldef=.FALSE.
                                    !            transfers=pen
                                    !        end if 
                                    !        if (welldef) then
									!			dec_mar(z,q,x,ia,index)=1
                                    !             vsum(1:2)=vec(1:2)+0.5_dp*surplus
                                    !             val=vsum(1:2)                                                
                                    !         else 
                                    !             dec_mar(z,q,x,ia,index)=0
                                    !             vsum=pen
									!			val=vec(1:2) 
                                    !        end if 

                                            if (yaz) then ; whereamI=5 ; dd(10)=one(welldef) ; call yaz_checknb(dd,vec,transfers,welldef) ; end if 
                                            !!!if (skriv.and.surplus+eps>0.0_dp.and.welldef==.FALSE.) then  ; whereamI=5 ; dd(10)=one(welldef) ; call yaz_checknb(dd,vec,transfers,welldef) ; end if 
                                            !if (skriv.and.ia==40.and.q==107.and.x==39) then  ; whereamI=5 ; dd(10)=one(welldef) ; call yaz_checknb(dd,vec,transfers,welldef) ; end if 
                                                                
                                           !if (  icheck_eqvmvf.and.qr==qp.and.xr==xp.and.  (abs(vec(1)-vec(2)) > eps .or. abs(vsum(1)-vsum(2)) > eps) ) then 
											!	print*, "vm not eq to vf!", ia,qr,xr,vec(1:4),vsum
											!	stop 
											!end if 
											if (yaz) then ; whereamI=5 ; dd(10)=one(welldef) ; vmax=vsum ; call yaz_decision(dd,vmax) ; end if 
											!no need for this ahu040518 vsingle(g,qp,xp,z)=val(g)	
											vm_s(qm,xm)=vm_s(qm,xm) + mgt(z) * ppmeetq(qm,qf) * ppmeetx(xm,xf) * val(1)
											vf_s(qf,xf)=vf_s(qf,xf) + mgt(z) * ppmeetq(qm,qf) * ppmeetx(xm,xf) * val(2)
										end do marshock 
									end if 
							        !no need for this ahu040518 end do sex 
							        !if (icheck_eqvmvf) then 
							        !	do z=1,nz
							        !		if ( abs(vsingle(1,qp,xp,z) - vsingle(2,qp,xp,z))>eps ) then 
							        !			write(*,'("vsingle not equal!!!")')
							        !			stop
							        !		end if 
							        !	end do 
							        !end if 
							end do 
						end do 							
						!moving this after the loop ahu040518 vm_s(qr,xr) = pmeet*vm_s(qr,xr) + (1.0_dp-pmeet)*vm0_s(qr,xr)
						!moving this after the loop ahu040518 vf_s(qr,xr) = pmeet*vf_s(qr,xr) + (1.0_dp-pmeet)*vf0_s(qr,xr)
						!if (  icheck_eqvmvf.and.abs(vm_s(qr,xr)-vf_s(qr,xr)) > eps ) then 
						!	print*, "vm not equal to vf!", ia,qr,xr,vm_s(qr,xr),vf_s(qr,xr)
						!	stop 
						!end if 
					end do 
				end do
				vm_s(:,:) = pmeet*vm_s(:,:) + (1.0_dp-pmeet)*vm0_s(:,:) !ahu 040518
				vf_s(:,:) = pmeet*vf_s(:,:) + (1.0_dp-pmeet)*vf0_s(:,:) !ahu 040518
                !vm_s=vm0_s
                !vf_s=vf0_s
                !dec_mar=0
                
				yaz=.false.
				if (skriv.and.(ia==mxa.or.ia==29).and.trueindex==1) yaz=.false.
				dd = -1 ; dd(1:2) = (/ia,trueindex/) 							! (/ ia,index,q,x,z,q0,g,j,altq,rel,iepsmove /)
				dd(7)=1 ; call getdec_s(dd,vm_s,decm_s(:,:,:,:,ia,index),vmr(:,:,:,:)     ) 
				dd(7)=2 ; call getdec_s(dd,vf_s,decf_s(:,:,:,:,ia,index),vfr(:,:,:,:)     ) 			
			end if 	! only singles or not

			do x0=1,nxs
				do q0=1,nqs
					if (q2w(q0)<=np1) then !state variable part of the q space i.e. w <= np1
						do x=1,nxs 
                            do q=1,nqs
                                do iepsmove=1,nepsmove
                                    !prob_s=matmul( reshape(ppsq(:,q0,x0,1),(/nqs,1/)) , reshape(ppsx(:,q0,x0),(/1,nxs/)) )
						            !emaxm_s(q0,x0,ia)	= sum( prob_s * vmr(:,:,q0) )		
                                    !prob_s=matmul( reshape(ppsq(:,q0,x0,2),(/nqs,1/)) , reshape(ppsx(:,q0,x0),(/1,nxs/)) )
						            !emaxf_s(q0,x0,ia)	= sum( probf_s * vfr(:,:,:,q0) )
                                    emaxm_s(q0,x0,ia)	= emaxm_s(q0,x0,ia) + ppso(iepsmove) * ppsq(q,q0,x0,1) * ppsx(x,q0,x0) * vmr(iepsmove,q,x,q0) 
                                    emaxf_s(q0,x0,ia)	= emaxf_s(q0,x0,ia) + ppso(iepsmove) * ppsq(q,q0,x0,2) * ppsx(x,q0,x0) * vfr(iepsmove,q,x,q0) 	
                                end do 
                            end do 
                        end do
                    end if !state variable part of the q space i.e. w <= np1
				end do 
			end do 

			yaz=.false.			
			if (skriv) call yaz1(index,ia) !ahu 0327. this was trueindex and corrected it to index.  
		end do ! age 
        end if ind
	end do !index
	!if ( (.not.chkstep).and.(.not.optimize) ) print*, "Finished solve and mysay is: ", mysay
	if (onlysingles) then
		dec_mar=0
	end if 
	insol=.false.
	end subroutine solve

	subroutine getdec_c(dd,vmax) 
	integer(i4b), intent(inout) :: dd(:)
	real(dp), intent(out) :: vmax(2) 
	real(dp) :: mcost(2),vsum(2),vec(5),surplusj(nc),transfers(2),vcheck(2),val(2),nashprod(nc),vdif(2),asum,vmario(2,nc)
	integer(i4b) :: ia,index,q,x,z,q0,g,jmax,qmax,relmax,iepsmove,i,i0,n,trueindex,j,de(1),ed(2),locch,loc0 !ahu032022 ahumarch2022
	logical :: welldef,defj(nc),haveenoughtomakeindiff,haveenoughtomakeindiff_alt,intsol(3),pc(2),pc_alt(2)
    !dd= (/ ia,index,q,x,z,q0,g,jmax,qmax,relmax,iepsmove /)  		
    !dd = (/ia,trueindex,q,x,z,q0,-1,-1,-1,-1,iepsmove /) 	! (/ ia,index,q,x,z,q0,gender,jmax,qmax,relmax,iepsmove /)  	
	ia=dd(1) 
	trueindex=dd(2) 
    if (groups) then 
        index=1
    else 
        index=trueindex
    end if
    q=dd(3) 
	x=dd(4) ; ed(:)=xx2e(:,x)     
	z=dd(5) 
	q0=dd(6)  
	iepsmove=dd(11)   
    vec=pen				! initialize
    !jmax=0				! initialize
    !qmax=0				! initialize
    !relmax=0            ! initialize
    !vmax=pen			! initialize
    !surplusmax=pen      ! initialize  
    surplusj=pen
    nashprod=pen        !ahu summer18 042318
    transfers=pen
    vmario=pen          !ahumarch1522 adding cornersol
    defj=.FALSE.
    i = qq2q(1,q) ; n=xx2x(1,x) ; i0 = qq2q(1,q0) 
    vec(1) = vm(iepsmove,i,n,i0,ia,index) + divpenalty
    mcost(1)=movecost(i0,n,trueindex)    
    i = qq2q(2,q) ; n=xx2x(2,x) ; i0 = qq2q(2,q0) 	
    vec(2) = vf(iepsmove,i,n,i0,ia,index) + divpenalty	
    mcost(2)=movecost(i0,n,trueindex)    
    loc0=qq2l(1,q0)     !ahumarch2022 ahu032022
	!ahu030822 adding the below in order to check the mar rates decreasing with mumar situation to compare chk2's better
	!if (yazmax) then !ahu030822
		!write(201,'("********************************")')
		!write(201,'(6x,tr5,"age",tr6,"q0",tr7,"q",tr7,"z",tr7,"j",tr4,"altq",tr1,"iepsmve",tr1,"trueind",tr1,"sex",TR3,"X",tr3,"def")' ) !ahu030822
			!write(201,'(6x,8i8,i4,I4,L6)')	ia,q0,q,z,j,i,iepsmove,trueindex,-1,X,defj(j)    ! altq is just the q that altrnative j corresponds to       !ahu03082
		    i = qq2q(1,q) ; n=xx2x(1,x) ; i0 = qq2q(1,q0) 
    		vec(1) = vm(iepsmove,i,n,i0,ia,index) + divpenalty
    		mcost(1)=movecost(i0,n,trueindex)    
    		i = qq2q(2,q) ; n=xx2x(2,x) ; i0 = qq2q(2,q0) 	
    		vec(2) = vf(iepsmove,i,n,i0,ia,index) + divpenalty	
    		mcost(2)=movecost(i0,n,trueindex)    
		    loc0=qq2l(1,q0)     
		    locq=qq2l(1,q)     
            vec(3) = vm0_c(q,x,ia,index)  + mg(z,trueindex) + one( locch /= loc0 ) * (mcost(1) + moveshock_m(iepsmove) ) 
            vec(4) = vf0_c(q,x,ia,index)  + mg(z,trueindex) + one( locch /= loc0 ) * (mcost(2) + moveshock_f(iepsmove) ) 
			vdif(1)=vec(3)-vec(1)
			vdif(2)=vec(4)-vec(2) 
			vec(5)=inctotales(q,x,trueindex)
            surq(iepsmove,q,x,q0,ia,index)= vec(5) + sum(vdif(1:2))   ! + vec(3) +vec(4) -vec(1)-vec(2)    !inctotales(q,x,trueindex) + vm0_c(q,x,ia,index) - vf0_c(q,x,ia,index) - vm(iepsmove,im,nm,i0m,ia,index) - vf(iepsmove,if,nf,i0f,ia,index)
            pc(1:2)	= ( vdif + eps >= 0.0_dp )	
            asum = sum(  one(.not. pc)  *   abs( vdif )   ) 
            haveenoughtomakeindiff=(  vec(5) + eps - asum  >= 0.0_dp  )
            intsol(1)=( vec(5) + eps >= abs(vdif(1)-vdif(2)) )  !interior
            intsol(2)=( vec(5) <= vdif(1)-vdif(2) + eps  )      !corner where c1=0 and c2=wsum !ahumarch2122 ahu032122 moving eps to the other side
            intsol(3)=( vec(5) <= vdif(2)-vdif(1) + eps  )      !corner where c1=wsum and c2=0 !ahumarch2122 ahu032122 moving eps to the other side

    choice: do j=1,nc	
        i = ch(j,q,q0)	!alternative q
        if (i>0 ) then	
			surj(j)=surq(iepsmove,i,x,q0,ia,index)
			defj(j)=defq(iepsmove,i,x,q0,ia,index)
			mj(j)=vemq(iepsmove,i,x,q0,ia,index)
			vefj(j)=vefq(iepsmove,i,x,q0,ia,index)
		end if
	end do !choice
    de=maxloc(surplusj,MASK=defj)
    jmax=de(1)
    if (jmax>0) then 
        qmax=ch(jmax,q,q0)
        relmax=1
        vmax(1)=vemj(jmax)
        vmax(2)=vefj(jmax)
    else
        qmax=0
        relmax=0
        vmax(1)=vm(iepsmove,im,nm,i0m,ia,index) 
        vmax(2)=vf(iepsmove,if,nf,i0f,ia,index)
    end if
	
			defq(iepsmove,q,x,q0,ia,index)
			surq(iepsmove,q,x,q0,ia,index)
			trmq(iepsmove,q,x,q0,ia,index)
			trfq(iepsmove,q,x,q0,ia,index)
			vemq(iepsmove,q,x,q0,ia,index)
			vefq(iepsmove,q,x,q0,ia,index)

            if (surpo+eps>0.0_dp .and. haveenoughtomakeindiff ) then
                    !ahumarch1522 Now check if the interior condition is really indeed satisfied but get rid of this later
                    if ( intsol(1) ) then       !ahumarch1522 interiorcheck adding cornersol
                        defq=.TRUE.          !ahumarch1522
               
                        !ahumarch2122 ahu032122 replacing with vdif to save time transfers(1) = alf * surplusj(j) - ( vec(3)-vec(1) )                                                
                        !ahumarch2122 ahu032122 replacing with vdif to save time transfers(2) = (1.0_dp-alf) * (vec(5) + vec(3) - vec(1) ) - alf*( vec(4)-vec(2) )   
                        trq(1) = alf * surpo -  vdif(1)                     !ahumarch2122 ahu032122 replacing with vdif to save time                                           
                        trq(2) = (1.0_dp-alf) * (vec(5) + vdif(1) ) - alf*vdif(2) !ahumarch2122 ahu032122 replacing with vdif to save time   
                        vmarioq(1:2,q)=vec(3:4)+transfers(1:2)
                    else if ( intsol(2) ) then                      !ahumarch1522 adding cornersol
                        defq=.TRUE.                              !ahumarch1522 adding cornersol
                        trq(1)=0.0_dp                         !ahumarch1522 adding cornersol
                        trq(2)=vec(5)                         !ahumarch1522 adding cornersol
                        vmarioq(1:2,q)=vec(3:4)+transfers(1:2)
                    else if ( intsol(3) ) then                      !ahumarch1522 adding cornersol
                        defq=.TRUE.                              !ahumarch1522 adding cornersol
                        trq(1)=vec(5)                         !ahumarch1522 adding cornersol
                        trq(2)=0.0_dp                         !ahumarch1522 adding cornersol
                        vmarioq(1:2,q)=vec(3:4)+transfers(1:2)
                    else 
                        print*, "Tried everything but I should not end up here"
                        stop
                    end if
            else    !NB not well defined either because surplus si negative off the bat or because don't have enough to make indiff
                defj(j)=.FALSE.
                surplusj(j)=pen
                !nashprod(j)=pen  !ahumarch1122 uncomenting this out
                transfers=pen
            end if 
	end do !choice 
	


j=jmax


            vec(3) = vm0_c(i,x,ia,index)  + mg(z,trueindex) + one( locch /= loc0 ) * (mcost(1) + moveshock_m(iepsmove) ) !ahumarch2022 ahu032022     
            vec(4) = vf0_c(i,x,ia,index)  + mg(z,trueindex) + one( locch /= loc0 ) * (mcost(2) + moveshock_f(iepsmove) ) !ahumarch2022 ahu032022
            !vec(5) = wc(1,i,x,trueindex) + wc(2,i,x,trueindex) + one( qq2w(1,q0)<=np )* ubc(1,i,x,trueindex) + one( qq2w(2,q0)<=np )* ubc(2,i,x,trueindex) + nonlabinc + nonlabinc 	 !ahu summer18 050318: added the ubc
            vec(5) = wc(1,i,x,trueindex) + wc(2,i,x,trueindex) + nonlabinc(ed(1)) + nonlabinc(ed(2)) 
            vdif(1)=vec(3)-vec(1)   !ahumarch1522 ahu031522 adding cornersol
            vdif(2)=vec(4)-vec(2)   !ahumarch1522 ahu031522 adding cornersol
            !ahumarch2122 ahu032122 replacing this with vdif for saving time surplusj(j) = vec(5) + vec(3) - vec(1) + vec(4) - vec(2)  
            surplusj(j) = vec(5) + sum(vdif(1:2))  !ahumarch2122 ahu032122 replacing with vdif for saving time
	        !surplus=vec(3)-vec(1)+vec(4)-vec(2)+vec(5)
            pc(1:2)	= ( vdif + eps >= 0.0_dp )	!pc(1:2)    = ( vec(3:4) - vec(1:2) >= 0.0_dp )						        
            !ahu032122 ahumarch2122 commenting out to save time pc_alt(1:2)=( vdif >= 0.0_dp )	
            asum = sum(  one(.not. pc)  *   abs( vdif )   ) 
            haveenoughtomakeindiff=(  vec(5) + eps - asum  >= 0.0_dp  )
            !ahu032122 ahumarch2122 commenting out to save time haveenoughtomakeindiff_alt=(  vec(5) - asum  >= 0.0_dp  )
            !In orer for NB to be well defined, we need: 1) surplus>=0 2) there exists some transfer such that transfer1>=0 and transfer2>=0
            !Condition 2 follows from the requirement that the utility transfer has to only come from current wsum and not the V's. In other words, 
            !w has to be such that it can cover any utility transfers that are needed o have the PC's hold. 
            !See notes in black notebook about why Condition 2 translates into that asum condition. 
            !Once we establish that NB is well defined, then we can go ahead and see if the optimum is interior or corner. 
            intsol(1)=( vec(5) + eps >= abs(vdif(1)-vdif(2)) )  !interior
            !ahumarch2122 ahu032122 moving eps to the other side intsol(2)=( vec(5) + eps < vdif(1)-vdif(2)   )      !corner where c1=0 and c2=wsum
            !ahumarch2122 ahu032122 moving eps to the other side intsol(3)=( vec(5) + eps < vdif(2)-vdif(1)   )      !corner where c1=wsum and c2=0
            intsol(2)=( vec(5) <= vdif(1)-vdif(2) + eps  )      !corner where c1=0 and c2=wsum !ahumarch2122 ahu032122 moving eps to the other side
            intsol(3)=( vec(5) <= vdif(2)-vdif(1) + eps  )      !corner where c1=wsum and c2=0 !ahumarch2122 ahu032122 moving eps to the other side

            if (surplusj(j)+eps>0.0_dp .and. haveenoughtomakeindiff ) then
                    !ahumarch1522 Now check if the interior condition is really indeed satisfied but get rid of this later
                    if ( intsol(1) ) then       !ahumarch1522 interiorcheck adding cornersol
                        defj(j)=.TRUE.          !ahumarch1522
                        !ahumarch2122 ahu032122 replacing with vdif to save time transfers(1) = alf * surplusj(j) - ( vec(3)-vec(1) )                                                
                        !ahumarch2122 ahu032122 replacing with vdif to save time transfers(2) = (1.0_dp-alf) * (vec(5) + vec(3) - vec(1) ) - alf*( vec(4)-vec(2) )   
                        transfers(1) = alf * surplusj(j) -  vdif(1)                     !ahumarch2122 ahu032122 replacing with vdif to save time                                           
                        transfers(2) = (1.0_dp-alf) * (vec(5) + vdif(1) ) - alf*vdif(2) !ahumarch2122 ahu032122 replacing with vdif to save time   
                        vmario(1:2,j)=vec(3:4)+transfers(1:2)
                        !ahumarch1522 Now check if the interior condition is really indeed satisfied but get rid of this later
                        !if (vec(5)-abs(vdif(1)-vdif(2)) < 0.0_dp ) then !ahumarch1522 if the transfers statement is correct, then this should be correct too!
                        !    print*, "There is something wrong!", vec(5),abs(vdif(1)-vdif(2))  !ahumarch1522
                        !    stop                                                    !ahumarch1522
                        !end if                                                      !ahumarch1522 
                        !if ( minval(transfers) + eps2 < 0.0_dp .or. maxval(transfers) > vec(5)+eps2 ) then ! if (minval(transfers)>0.0_dp.and.maxval(transfers)<vec(5) ) then 
                        !    print*, "Int cond fine but transfers not fine!", transfers(1:2),vec(5)  !ahumarch1522
                        !    stop                                                                    !ahumarch1522                            
                        !end if 
                        !if ( minval(transfers) < 0.0_dp .or. maxval(transfers) > vec(5) ) then ! if (minval(transfers)>0.0_dp.and.maxval(transfers)<vec(5) ) then 
                        !    print*, "Int cond fine but transfers not fine 2!", transfers(1:2),vec(5)  !ahumarch1522
                        !    stop                                                                    !ahumarch1522                            
                        !end if 
                    else if ( intsol(2) ) then                      !ahumarch1522 adding cornersol
                        defj(j)=.TRUE.                              !ahumarch1522 adding cornersol
                        transfers(1)=0.0_dp                         !ahumarch1522 adding cornersol
                        transfers(2)=vec(5)                         !ahumarch1522 adding cornersol
                        vmario(1:2,j)=vec(3:4)+transfers(1:2)
                        !if (vec(5) >= vdif(1)-vdif(2) ) then        !ahumarch1522 adding cornersol
                        !    print*, "There is somethingwrong in corner1!", vec(5),vdif(1)-vdif(2)  !ahumarch1522 adding cornersol
                        !    stop
                        !end if                                       !ahumarch1522 adding cornersol
                    else if ( intsol(3) ) then                      !ahumarch1522 adding cornersol
                        defj(j)=.TRUE.                              !ahumarch1522 adding cornersol
                        transfers(1)=vec(5)                         !ahumarch1522 adding cornersol
                        transfers(2)=0.0_dp                         !ahumarch1522 adding cornersol
                        vmario(1:2,j)=vec(3:4)+transfers(1:2)
                        !if (vec(5) >= vdif(2)-vdif(1) ) then        !ahumarch1522 adding cornersol
                        !    print*, "There is somethingwrong in corner2!", vec(5),vdif(1)-vdif(2)  !ahumarch1522 adding cornersol
                        !    stop
                        !end if                                       !ahumarch1522 adding cornersol
                    else 
                        print*, "Tried everything but I should not end up here"
                        stop
                    end if
            else    !NB not well defined either because surplus si negative off the bat or because don't have enough to make indiff
                defj(j)=.FALSE.
                surplusj(j)=pen
                !nashprod(j)=pen  !ahumarch1122 uncomenting this out
                transfers=pen
            end if 
            if (yaz) call yaz_checknb(dd,vec,transfers,defj(j))
			!ahu030822 adding the below in order to check the mar rates decreasing with mumar situation to compare chk2's better
			!if (yazmax) then !ahu030822	
				!write(201,'(6x,tr5,"age",tr6,"q0",tr7,"q",tr7,"z",tr7,"j",tr4,"altq",tr1,"iepsmve",tr1,"trueind",tr1,"sex",TR3,"X",tr3,"def")' ) !ahu030822
				!write(201,'(6x,8i8,i4,I4,L6)')	ia,q0,q,z,j,i,iepsmove,trueindex,-1,X,defj(j)    ! altq is just the q that altrnative j corresponds to       !ahu030822
			!end if !ahu030822
            !if (skriv.and.surplusj(j)+eps>0.0_dp.and.defj(j)==.FALSE.) call yaz_checknb(dd,vec,transfers,defj(j))
        
                   
        !ahu summer18 050718
        !if ( (nashprod(j)==pen.and.surplusj(j)/=pen)  .or. (nashprod(j)/=pen.and.surplusj(j)==pen)  ) then 
        !    print*, 'Here it is they are not equal',surplusj(j),nashprod(j)
        !    stop
        !end if 
        end if !q0
    end do choice    
    jmax=0
    !ahu summer18 042318 de=maxloc(surplusj,MASK=defj)
    !ahu summer18 050718: the two are the same i.e. mazing surplus and nashprod are the same. surplus is just 2 times nashprod. 
    !so I will go back to maxing surplus because htat is quicker than nashprod calculation. and also the cluster is very slow whenever it's nashprod.
    !but could not figure out why exactly. it might be because the within paranthesis part get very close to 0 but not sure. 
    !de=maxloc(nashprod,MASK=defj)
    de=maxloc(surplusj,MASK=defj)
    jmax=de(1)
    if (jmax>0) then 
        qmax=ch(jmax,q,q0)
        relmax=1
        !vmax(1:2)=vec(1:2)+0.5_dp*surplusj(jmax)
        vmax(1:2)=vmario(1:2,jmax)
    else
        qmax=0
        relmax=0
        vmax(1:2)=vec(1:2)
    end if
    dd(8)=jmax
    dd(9)=qmax
    dd(10)=relmax 
	if (yazmax) then !ahu030822
		write(201,'(2x,tr1,"age",tr2,"q0",tr3,"q",tr2,"qt",tr2,"ie",TR3,"X",tr1,"rel")' ) !ahu030822
		write(201,'(2x,7i4)')	ia,q0,q,qmax,iepsmove,X,relmax    ! altq is just the q that altrnative j corresponds to       !ahu030822
	end if !ahu030822
    ! if no gains from marriage, then divorce or stay single 
    !if (relmax==0) then 
    !	vmax=vec(1:2)       !don't need vmax in sim
    !end if  
    end subroutine getdec_c

    ! Look at dropbox/familymig/v130814/Source2 and Source11 and temp_010413 for the old versions of this
	subroutine checknb( dd, vec , def ,vsum)   
	integer, intent(in) :: dd(:) 
	real(dp), intent(in) :: vec(5)        
	logical, intent(out) :: def
	real(dp), intent(out) :: vsum(2)
	real(dp) :: surplus,transfers(2)
	vsum = pen ; transfers=pen 
	def  = .FALSE.
    surplus = vec(5) + vec(3) - vec(1) + vec(4) - vec(2)  
	if ( surplus + eps >= 0.0_dp )  then
		transfers(1) = alf * surplus - ( vec(3)-vec(1) )                                                    ! wage
		transfers(2) = (1.-alf) * (vec(5) + vec(3) - vec(1) ) - alf*( vec(4)-vec(2) )                       ! firm payoff
        !if (transfers(1) < 0.0_dp) cornersol=(/ 0._dp,vec(5) /) 
		!if (transfers(2) < 0.0_dp) cornersol=(/ vec(5),0._dp /) 
        !if not corner if statement. but not sure if this is right. look at the other tries below. 
        !because the below checks for corner solution o rinterior solution (checking transfers>0 or <w afterwards is the same as 
        !by the way checking the condition for checking FOC at corners 0 and w. see notes p.3 . 
        !but before this you need to figure otu whether there are 
        !any feasible utility allocations through doing that checking: 
        !asum = sum(  abs(.not. pc)  *   abs( vdif )   )
	    !def  = ( w + eps - asum  >= 0.0_dp )
    
		if ( minval(transfers) + eps >= 0.0_dp .and. maxval(transfers) < vec(5) ) then ! if (minval(transfers)>0.0_dp.and.maxval(transfers)<vec(5) ) then 
            def=.TRUE.
		    vsum(1) = transfers(1) + vec(3)      ! vsum is the value function after all transfers are made. i.e. vsum = wage + beta*EV_worker         ! vec(3) is just beta*EV i.e. what the worker has before transfers are made
		    vsum(2) = transfers(2) + vec(4)      ! vsum = firmpayoff + beta*EV_firm     ! " 
            if ( vsum(1) + eps < vec(1) .or. vsum(2) + eps < vec(2) ) then
                print*, "Transfers positive and less than wages but someone is getting a bad deal "
		        write(*,'(2x,2(tr6,"vbar"),2(tr8,"vc"),tr8,"wc",tr6,"surp")' )    
		        write(*,'(2x,6f10.2)') vec,surplus
		        write(*,'(2x,2(tr5,"trans"),2(tr6,"vsum") )' )    
		        write(*,'(2x,4f10.2)') transfers,vsum
                write(*,*) vsum(1)-vec(1),vsum(2)-vec(2)
            end if 
        end if
	end if
	!if (yaz) then    !.and.(dd(1)==30.and.def) ) then    !.and.minval(vsum)<0.0_dp) then 
	!	call yaz_checknb(dd,vec,transfers,def)
	!end if 
	end subroutine checknb

	!if ( pc(1) .and. pc(2) ) then	
	!	def  = .true.				
	!else 
	!	asum = sum(  abs(.not. pc)  *   abs( vdif )   )
	!	def  = ( w + eps - asum  >= 0.0_dp )
	!end if 
	!if (def) then 
	!	vsum	= vec(1:2) + 0.5_dp * ( w + eps + sum(vdif) )
	!	if ( vsum(1) < vec(1) .or. vsum(2) < vec(2) ) then 
	!		print*, "error in checknb " ,vsum(1)-vec(1),vsum(2)-vec(2),( w - asum  >= 0.0_dp ),w,asum,pc,w + sum(vdif) 
	!		print*, "vdif(2),wf_s,wf_s+vdif(2),wf_s+vdif(2) ", vdif(2)  !,wagetemp(2),wagetemp(2) + vdif(2),wagetemp(2) + vec(4) - vec(2) 
	!		stop 
	!	end if
	!end if 
	!if (yaz) then    !.and.(dd(1)==30.and.def) ) then    !.and.minval(vsum)<0.0_dp) then 
	!	call yaz_checknb(dd,vec,vdif,pc,asum,vsum,def)
	!end if 
	!end subroutine checknb

	!vsum = penaltyval 
	!transfers = penaltyval
	!def  = .FALSE.
	!criter=.FALSE.
	!surplus = vec(5) + vec(3) - vec(1) + vec(4) - vec(2)  
	! CASE 1: NO CONSTRAINT ON TRANSFERS. I.E. WAGES AND FIRM SHARES CAN BE NEGATIVE. 
	!         When there are no limits on what can be transferred, the only criterion for NB to be well-defined is simply that the match surplus is positive.  
	!if (nonneg_constraint==0) then                      ! no nonneg constraints for wages nor firm payoff  
	!	def = ( surplus + eps >= 0.0 )                  ! When there are no limits on what can be transferred btw parties, the only criterion for NB to be well defined is that surplus is positive. 
		
	! CASE 2: NONNEGATIVITY CONSTRAINTS ON TRANSFERS: 
	!           So that transfers can only come from current period resources. Cannot borrow from the continuation values to pay the other party today. 
	!           This limits the set of of feasible allocations and therefore the number of times NB is welldefined is less in this case. Because now any divsion of total surplus can only be implemented by using current period resources, which might not be enough sometimes. 
	!else if (nonneg_constraint==2) then                 ! see notes for how the nonneg constraints mean that the match surplus (outputnet) needs to satisfy the following three criteria
	!	criter(1) = ( vec(5) + eps >= vec(1) - vec(3) ) 
	!	criter(2) = ( vec(5) + eps >= vec(2) - vec(4) ) 
	!	criter(3) = ( vec(5) + eps >= vec(1) - vec(3) + vec(2) - vec(4) ) 
	!	def = ( criter(1) .and. criter(2) .and. criter(3) ) 
	!end if 
	

	! Check interior opt conditions 
	! If NB is well defined, then take FOC to get optimal transfers (wage and firm payoffs)
	!if (def) then 
	!	transfers(1) = alpha * surplus - ( vec(3)-vec(1) )                                                      ! wage
	!	transfers(2) = (1.-alpha) * (vec(5) + vec(3) - vec(1) ) - alpha*( vec(4)-vec(2) )                       ! firm payoff
	!	if (transfers(1) < 0.) transfers=(/ 0.,vec(5) /) 
	!	if (transfers(2) < 0.) transfers=(/ vec(5),0. /) 
	!	vsum(1) = transfers(1) + vec(3)      ! vsum is the value function after all transfers are made. i.e. vsum = wage + beta*EV_worker         ! vec(3) is just beta*EV i.e. what the worker has before transfers are made
	!	vsum(2) = transfers(2) + vec(4)      ! vsum = firmpayoff + beta*EV_firm     ! " 
	!	if (writeval) then ! if want to check whether things look right: check whether vsum's and the below temp's are equal. they should be since they are the same way of calculating value functions after the transfers.        
	!   end if 
	!end if 
	

	subroutine getdec_s_old(dd,vs,qs,vs1)
	integer(i4b), intent(in) :: dd(:)
	real(dp), dimension(nqs,nxs), intent(in) :: vs
	integer(i4b), dimension(nepsmove,nqs,nxs,nqs), intent(out) :: qs
	real(dp), dimension(nepsmove,nqs,nxs,nqs), intent(out) :: vs1
	real(dp), dimension(np2,nl) :: dumv0,dumv1,dumv2,dumv
    real(dp) :: v0,v_cond_u,vbar,totmovecost(nl),moveshock(nepsmove)
	integer(i4b) :: q0,q,qbar,qstar,q_cond_u,l,l_cond_u,w,x,ss(size(dd,1)),iepsmove,iepskid,sex,index,trueindex

    trueindex=dd(2)
    sex=dd(7)
	qs = -1 ; vs1 = 0.0_dp
    if (groups) then 
        index=1
    else 
        index=trueindex
    end if
    if (sex==1) then 
        moveshock=moveshock_m
    else if (sex==2) then 
        moveshock=moveshock_f
    else 
        print*, 'decs something wrong'
        stop
    end if 
	do q0=1,nqs
		if ( q2w(q0)<=np1 ) then 
			do x=1,nxs
                dumv0(:,:) = reshape( vs(:,x) , (/ np2, nl /) )	                ! turn q index into its components (w,l)
                !dumv1(:,:) = reshape( ubs(sex,:,x,trueindex) , (/ np2, nl /) )	! turn q index into its components (w,l)    !ahu summer18 050318
                !dumv2 = dumv0 + dumv1 * one(q2w(q0) <= np)                      !!ahu summer18 050318: !if they were working the previous period, then they get to collect unemp benefit but not otherwise
                dumv2=dumv0
                
                moveshocks: do iepsmove=1,nepsmove
				    !Before drawing the rest of the shocks (ofloc and wagedraw), determine some max options conditional on unemployment and given status quo (no need to know the ofloc and wagedraw for this)
                    totmovecost(:)=movecost(q0,x,trueindex) + scst ; totmovecost(q2l(q0))=moveshock(iepsmove) !0.0_dp
                    do w=1,np1
					    dumv(w,:) = dumv2(w,:) + totmovecost(:) !ahu summer18 050318 turned dumv0 into dumv2
				    end do 
                    
				    l_cond_u=maxloc(dumv(np1,:),1)	! max location option conditional on unemployment 
				    q_cond_u=wl2q(np1,l_cond_u )    ! turn that into q
				    v_cond_u=dumv(np1,l_cond_u)		! max val conditional on unemployment
				    v0=dumv(q2w(q0),q2l(q0))		! value at status quo
				    if (v0>v_cond_u) then			! choice btw status quo (vs(q0,x)) and max unemployment option (vs(i,x) calculted above:
					    vbar=v0 ; qbar=q0
				    else 
					    vbar=v_cond_u	  ; qbar=q_cond_u
				    end if 					
				    if ( q2w(qbar)==np2) then ; print*, "in getdec_s and q2w(j) is np2 " ; stop ; end if 
				    if (qbar==0) then ; print*, "in getdec_s: j is 0 ", dd(1),dd(2) ; stop ; end if 
				    ofloc: do l=1,nl											
					    !r = locate( real(dumv(1:np,l)) , real(vs(j,x))   )	! res wage for each location l, above which you accept the offer from location l
					    wagedraw: do w=1,np2
						    q = wl2q(w,l)
						    if (w <= np) then 
							    qstar = qbar*one( dumv(w,l)<=vbar) + q*one(dumv(w,l)>vbar)
						    else if (w == np1) then 
							    qstar  = q_cond_u	! if you get laid off, the only things to choose from are unemployment option and the max thing to do is qu in that case which is calculated above 
						    else if (w == np2) then 
							    qstar  = qbar		! if nothing happens then choice is q0u which is the maximum btw status quo and the best unemployment option 
						    end if 		
						    if (q2w(qstar)==np2) then ; print*, "in getdec_s and q2w(qstar) is np2 " ; stop ; end if 
						    qs(iepsmove,q,x,q0)  =  qstar				
						    vs1(iepsmove,q,x,q0) =	dumv(q2w(qstar),q2l(qstar))
                            !if (     abs( vs(qstar,x) - dumv(q2w(qstar),q2l(qstar))+ totmovecost(q2l(qstar))    )   > eps ) then ; print*, "in getdec_s and vs/=dumv ",vs(qstar,x),dumv(q2w(qstar),q2l(qstar))-totmovecost(q2l(qstar)) ; stop ; end if  		
						    if (yaz.and.q2w(q0)==1.and.l==8.and.x==1) then
							    ss = dd  !(/ ia,index,q,x,z,q0,gender,j,altq,iepsmove /)  													
							    ss(3:6)= (/q,x,-1,q0/)
                                ss(11)=iepsmove
							    !call yaz_decs(ss,qstar,v0,v_cond_u,vbar,dumv)   !look here
						    end if 
                        end do wagedraw
				    end do ofloc
                end do moveshocks
			end do  !x 				
		end if		! w0<=np1 i.e. ps0(q0) is true
	end do			! q0
	end subroutine getdec_s_old


	subroutine getdec_s(dd,vs,qs,vs1)
	integer(i4b), intent(in) :: dd(:)
	real(dp), dimension(nqs,nxs), intent(in) :: vs
	integer(i4b), dimension(nepsmove,nqs,nxs,nqs), intent(out) :: qs
	real(dp), dimension(nepsmove,nqs,nxs,nqs), intent(out) :: vs1
	integer(i4b) :: q0,q,l,l0,w,x,i,j,iepsmove,sex,index,trueindex,jstar(1),age,ss(size(dd,1))
    real(dp) :: mcost,vcho(ncs),moveshock(nepsmove),bshock(nepsmove)

    trueindex=dd(2)
    sex=dd(7)
	qs = -1 ; vs1 = 0.0_dp
    if (groups) then 
        index=1
    else 
        index=trueindex
    end if
    if (sex==1) then 
        moveshock=moveshock_m
        bshock=bshock_m
    else if (sex==2) then 
        moveshock=moveshock_f
        bshock=bshock_f
    else 
        print*, 'decs something wrong'
        stop
    end if 
	do q0=1,nqs
        l0=q2l(q0)
		if ( q2w(q0)<=np1 ) then 
			do x=1,nxs
                mcost=movecost(q0,x,trueindex)                
                moveshocks: do iepsmove=1,nepsmove
				    ofloc: do l=1,nl											
					    wagedraw: do w=1,np2
						    q = wl2q(w,l)

                            vcho=pen
                            choice: do j=1,ncs	
                                i = chs(j,q,q0)	!alternative q
                                if (i>0 ) then		
                                    if (q2w(i)<=np) then
                                        vcho(j) = vs(i,x) + one(q2l(i)/=l0) * mcost + one( q2l(i)/=l0) * moveshock(iepsmove)  !fnmove(kid)  
                                    else if (q2w(i)==np1) then 
                                        vcho(j) = vs(i,x) + one(q2l(i)/=l0) * mcost + one( q2l(i)/=l0) * moveshock(iepsmove) + bshock(iepsmove)   
                                    end if                                         
                                end if 
                            end do choice
                            
                            				
						    vs1(iepsmove,q,x,q0) =	maxval(vcho)
                            jstar(1)=maxloc(vcho,1)
                            qs(iepsmove,q,x,q0)  =  chs(jstar(1),q,q0)
                            if ( vs1(iepsmove,q,x,q0) < pen+1.0_dp) then 
                                print*, 'There is something wrong in decs new new new',vs1(iepsmove,q,x,q0),dd(1),moveshock(iepsmove),mcost
                                print*, 'vcho',vcho
                                stop
                            end if 
                            
						    if (yaz .and.q2w(q0)==1.and.l==8.and.x==1) then
							    ss = dd  !(/ ia,index,q,x,z,q0,gender,j,altq,iepsmove /)  													
							    ss(3:6)= (/q,x,-1,q0/)
                                ss(11)=iepsmove
							    call yaz_decs(ss,vcho)   !look here
						    end if 
                            
                    	 end do wagedraw
				    end do ofloc
                end do moveshocks
			end do  !x 				
		end if		! w0<=np1 i.e. ps0(q0) is true
	end do			! q0
	end subroutine getdec_s

    
	subroutine get_util_w
	integer(i4b) :: q,x,w(2),l(2),kid(2),ed(2),expe(2),trueindex,trueco,truetyp,truehome,g,j,k
    real(dp) :: epsw(2) !RHO(2,2),CD(2,2),
    
    utils=pen
    utilc=pen
    ws=pen
    wc=pen   
    



    do trueindex=1,ninp    
    call index2cotyphome(trueindex,trueco,truetyp,truehome)
    xs: do x=1,nxs
        !call x2edexpkid(x,ed,exp,kid)    
		qs: do q=1,nqs 
            movecost(q,x,trueindex)=fnmove( q2w(q),x2kid(x),trueindex)
            do g=1,2
                w(g) = q2w(q)						! wage 
			    l(g) = q2l(q)						! location
			    if ( w(g) <= np ) then	
                    epsw(g)=wg(w(g),g) !sig_wge(g)*wg(w(g),g)
				    ws(g,q,x,trueindex)	= fnwge(g,truetyp, l(g),epsw(g), x2e(x), x2r(x)) 
			    !    ubs(g,q,x,trueindex)	= 0.0_dp                                                            !ahu summer18 050318
                else if ( w(g) == np1 ) then 
			    !    epsw(g)=0.0_dp                                                                              !ahu summer18 050318
                    ws(g,q,x,trueindex)	 = 0.0_dp
                !    ubs(g,q,x,trueindex)	= replacement_rate*fnwge(g,truetyp, l(g),epsw(g), x2e(x), x2r(x))   !ahu summer18 050318
                end if 
                
			    if ( w(g) <= np ) then						
				    utils(g,q,x,trueindex)	= uhome(g) * one(l(g)==truehome) + uloc(l(g)) + nonlabinc(x2e(x))
			    else if ( w(g) == np1 ) then 
				    utils(g,q,x,trueindex)	= uhome(g) * one(l(g)==truehome)  + uloc(l(g)) + alphaed(g,x2e(x)) + alphakid(g,x2kid(x))  + nonlabinc(x2e(x))
			    end if
                
            end do !gender
		end do qs
	end do xs
	xc: do x=1,nx
        ed(:)=xx2e(:,x)    
        expe(:)=xx2r(:,x)    
        kid(:)=xx2kid(:,x)    
        qc: do q=1,nq
			w(:) = qq2w(:,q)						! wage 
			l(:) = qq2l(:,q)						! location
            if (l(1).ne.l(2)) then ; print*, 'lm not equal to lf' ; stop ; end if 

            !******************************
            !ahu summer18 050318 
            !if (w(1)<=np) then 
            !    ubc(1,q,x,trueindex)	= 0.0_dp           
            !else if (w(1)==np1) then 
            !    epsw(1)=0.0_dp
            !    ubc(1,q,x,trueindex)	= replacement_rate*fnwge(1,truetyp, l(1),epsw(1), ed(1), expe(1) ) 
            !end if 
            !if (w(2)<=np) then 
            !    ubc(2,q,x,trueindex)	= 0.0_dp           
            !else if (w(2)==np1) then 
            !    epsw(2)=0.0_dp
            !    ubc(2,q,x,trueindex)	= replacement_rate*fnwge(2,truetyp, l(2),epsw(2), ed(2), expe(2) ) 
            !end if 
            !ahu summer18 050318 
            !******************************
            
            if ( w(1) <= np .and. w(2) <= np ) then		
                epsw(1)=wg(w(1),1) !CD(1,1)*wg(w(1),1)
                epsw(2)=wg(w(2),2) !CD(2,1)*wg(w(1),1) + CD(2,2)*wg(w(2),2)
				wc(1,q,x,trueindex)	= fnwge(1,truetyp, l(1),epsw(1), ed(1), expe(1) ) 
                wc(2,q,x,trueindex)	= fnwge(2,truetyp, l(2),epsw(2), ed(2), expe(2) )  
            else if ( w(1) <= np .and. w(2) == np1 ) then		
                epsw(1)=wg(w(1),1) !sig_wge(1)*wg(w(1),1)
				wc(1,q,x,trueindex)	= fnwge(1,truetyp, l(1),epsw(1), ed(1), expe(1) ) 
				wc(2,q,x,trueindex)	= 0.0_dp
            else if ( w(1) == np1 .and. w(2) <= np ) then		
                epsw(2)=wg(w(2),2) !sig_wge(2)*wg(w(2),2)
				wc(1,q,x,trueindex)	= 0.0_dp
				wc(2,q,x,trueindex)	= fnwge(2,truetyp, l(2),epsw(2), ed(2), expe(2) )                      
            else if ( w(1) == np1 .and. w(2) == np1 ) then		
				wc(1,q,x,trueindex)	= 0.0_dp
				wc(2,q,x,trueindex)	= 0.0_dp                 
			end if 
            
            
            do g=1,2
			    if ( w(g) <= np ) then						
				    utilc(g,q,x,trueindex)	= uhome(g) * one(l(g)==truehome)   + uloc(l(g))
			    else if ( w(g) == np1 ) then 
				    utilc(g,q,x,trueindex)	= uhome(g) * one(l(g)==truehome)   + uloc(l(g)) + alphaed(g,ed(g) ) + alphakid(g,kid(g))
			    end if
            end do   
            
            !if (skriv) write(88881,'(3I4,4F10.2)') q,x,k,w1(i(1),j(1),k),w2(i(2),j(2),k),w3(q,x,k),w4(q,x,k)
        end do qc
	end do xc
    end do !trueindex
    
    
    !Male and female wage shocks for each period and from each location
!    do it=1,nt
!	    do iloc=1,nloc
!		    do rn=1,nn
!			    up1(it,rn,iloc)=CD(1,1)*rv1(it,rn,iloc)
!			    up2(it,rn,iloc)=CD(2,1)*rv1(it,rn,iloc)+CD(2,2)*rv2(it,rn,iloc)
!		    end do 
!	    end do
!    end do 

	end subroutine get_util_w
    
    
end module sol


